# 管理 Kubernetes 对象

`kubectl` 命令行工具支持多种不同的方式来创建和管理 Kubernetes 对象。

## 管理技巧

{% hint style="danger" %}
<mark style="color:red;">**警告：**</mark>

一个 Kubernetes 对象应该只使用一种技术来管理。混合和匹配技术作用在同一对象上将会导致未定义行为。
{% endhint %}

| **管理技术**    | **作用于**  | **建议的环境** | **支持的写者** | **学习难度** |
| ------- | ---- | ----- | ----- | ---- |
| 指令式命令   | 活跃对象 | 开发项目  | 1+    | 最低   |
| 指令式对象配置 | 单个文件 | 生产项目  | 1     | 中等   |
| 声明式对象配置 | 文件目录 | 生产项目  | 1+    | 最高   |

## 指令式命令

使用指令式命令时，用户直接对集群中的活跃对象进行操作。`kubectl` 命令后跟着参数或标示。

这是在集群中运行一次性任务的推荐方式。由于直接在活跃对象上运行，因此不提供以前配置的历史记录。

### 例子

```bash
kubectl create deployment nginx --image nginx
```

### 比较

与对象配置相比，优点有：

* 命令简单，易学且易于记忆。
* 命令仅需一个步骤即可对集群进行更改。

与对象配置相比，缺点有：

* 命令不与变更审查过程集成。
* 命令不提供与更改关联的审核跟踪。
* 除了实时内容外，命令不提供记录源。
* 命令不提供用于创建新对象的模板。

## 指令式对象配置

在指令式对象配置中，`kubectl` 命令指定操作（创建、替换等）和至少一个文件名，以及可选的标志。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。

{% hint style="danger" %}
<mark style="color:red;">**警告：**</mark>

`replace` 操作将现有规范替换为新提供的规范，并放弃对配置文件中缺少的对象的所有更改。此方法不应与对象 spec 被独立于配置文件进行更新的资源类型一起使用。比如，类型为 `LoadBalancer` 的服务，它的 `externalIPs` 字段就是独立于集群配置进行更新。
{% endhint %}

### 例子

根据配置文件创建对象：

```bash
kubectl create -f nginx.yaml
```

删除两个配置文件中定义的对象：

```bash
kubectl delete -f nginx.yaml -f redis.yaml
```

替换集群中相同资源相同名称的对象：

```bash
kubectl replace -f nginx.yaml
```

### 比较

* 与指令式命令相比
  * 优点：
    * 对象配置可以存储在源控制系统中，比如 git。
    * 对象配置可以与流程集成，比如，在推送和审计之前检查更新。
    * 对象配置提供了用于创建新对象的模板。
  * 缺点：
    * 对象配置需要对对象架构有基本的了解。
    * 对象配置需要额外的步骤来编写 YAML 文件。
* 与声明式对象配置相比
  * 优点：
    * 指令式对象配置行为更加简单易懂。
    * 从 Kubernetes 1.5 版本开始，指令式对象配置更加成熟。
  * 缺点：
    * 指令式对象配置更适合文件，而非目录。
    * 对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失。

## 声明式对象配置

使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户未定义要对文件执行的操作。`kubectl` 会自动检测每个文件的创建、更新和删除操作。这使得配置可以目录上工作，根据目录中配置文件对不同的对象执行不同的操作。

{% hint style="info" %}
<mark style="color:blue;">**说明：**</mark>

声明式对象配置保留其他编写者所做的修改，即使这些更改并未合并到对象配置文件中，可以通过使用 `patch` API 操作仅写入观察到的差异，而不是使用 `replace` API 操作来替换整个对象配置来实现。
{% endhint %}

### 例子

处理 configs 目录中的所有对象配置文件，创建并更新活跃对象。可以首先使用 `diff` 命令查看将要进行的更改，然后在进行应用：

```bash
kubectl diff -f configs/
kubectl apply -f configs/
```

递归目录：

```bash
kubectl diff -R -f configs/
kubectl apply -R -f configs/
```

### 比较

与指令式对象配置相比，优点：

* 对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。
* 声明式对象配置更好地支持对目录进行操作，并自动检测每个文件的操作类型（创建、更新、删除）。

与指令式对象配置相比，缺点：

* 声明式对象配置难于调试并助出现异常时结果难以理解。
* 使用 `diff` 命令产生的部分更新会创建复杂的合并和更新操作。
